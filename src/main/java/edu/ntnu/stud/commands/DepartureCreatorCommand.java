package edu.ntnu.stud.commands;

import static edu.ntnu.stud.utils.Constants.REGEX_24HR_FORMAT;
import static edu.ntnu.stud.utils.Constants.REGEX_DESTINATION_FORMAT;
import static edu.ntnu.stud.utils.Constants.REGEX_LINE_FORMAT;
import static edu.ntnu.stud.utils.Constants.REGEX_TRACK_FORMAT;
import static edu.ntnu.stud.utils.Constants.REGEX_TRAINID_FORMAT;
import static edu.ntnu.stud.utils.Constants.REGEX_YN_FORMAT;

import edu.ntnu.stud.exceptions.InvalidDepartureException;
import edu.ntnu.stud.input.InputHandler;
import edu.ntnu.stud.models.DepartureTable;
import edu.ntnu.stud.models.TrainDeparture;
import edu.ntnu.stud.utils.Halt;
import edu.ntnu.stud.utils.Renderer;
import java.time.LocalTime;
import java.util.Random;

/**
 * Class for adding a departure.
 */
public class DepartureCreatorCommand extends Command {

  private final Random random;

  /**
   * Constructor for the DepartureCreatorCommand class.
   *
   * @param random the random number generator.
   */
  public DepartureCreatorCommand(Random random) {
    super("Add a departure to the departure table");
    this.random = random;
  }


  @Override
  public void run(DepartureTable table) throws InvalidDepartureException {
    // Get delay for the new departure from the user
    String delayString = inputHandler.getInput(
        "Enter the delay of the departure",
        "[HH:MM]",
        REGEX_24HR_FORMAT,
        false);

    // Get the new departure time from the user
    String timeString = inputHandler.getInput(
        "Enter the scheduled time of the departure",
        "[HH:MM]",
        REGEX_24HR_FORMAT,
        false);

    LocalTime delay = LocalTime.parse(delayString);
    LocalTime scheduledTime = LocalTime.parse(timeString);

    // Check if the adjusted time will be valid (not past midnight or before current time)
    inputHandler.isAdjustedTimeValid(table, delay, scheduledTime);

    // Get the line for the new departure from the user
    String line = inputHandler.getInput(
        "Enter the line of the departure",
        "[A-D][1-9]",
        REGEX_LINE_FORMAT,
        false);

    // Get the train ID for the new departure from the user
    int trainId = getTrainId(table, inputHandler);

    // Get the destination of the new departure from the user
    String destination = inputHandler.getInput(
        "Enter the destination of the departure",
        "[a-Z]",
        REGEX_DESTINATION_FORMAT,
        false);

    // Get the track for the new departure from the user
    int track = getTrack(inputHandler);

    // Create the new departure
    TrainDeparture departure = new TrainDeparture(
        scheduledTime,
        line,
        trainId,
        destination,
        delay,
        track);

    // Present the new departure to the user and ask if it is correct
    verifyDetails(table, inputHandler, departure);
  }


  // Method for auto-generating a train ID
  private int autogenerateTrainId(DepartureTable table) {
    int trainId;

    do {
      trainId = 1000 + random.nextInt(9000);
    } while (!isIdUnique(table, trainId));

    System.out.println("Autogenerated train ID: " + trainId);

    return trainId;
  }


  // Method for checking whether a given train ID is unique
  private boolean isIdUnique(DepartureTable table, int trainId) {
    return table.getDepartureList().stream()
        .filter(departure -> departure.getTrainId() == trainId).findAny().isEmpty();
  }


  // Method for getting a train ID from the user
  private int getTrainId(DepartureTable table,
                         InputHandler inputHandler) throws InvalidDepartureException {
    String trainIdString = inputHandler.getInput(
        "Enter a unique train ID for the departure, or leave blank to autogenerate",
        "[1000-9999]",
        REGEX_TRAINID_FORMAT,
        true);

    if (trainIdString.isEmpty()) {
      return autogenerateTrainId(table);

    } else if (isIdUnique(table, Integer.parseInt(trainIdString))) {
      return Integer.parseInt(trainIdString);

    } else {
      throw new InvalidDepartureException("Train ID '" + trainIdString + "' is already in use.");
    }
  }


  // Method for getting a track from the user
  private int getTrack(InputHandler inputHandler) {
    String trackString = inputHandler.getInput(
        "Enter the track of the departure, or leave blank if unknown",
        "[1-5]",
        REGEX_TRACK_FORMAT,
        true);

    // Return -1 if the track is unknown (blank response)
    if (trackString.isEmpty()) {
      return -1;
    } else {
      return Integer.parseInt(trackString);
    }
  }


  // Method for verifying the details of the new departure
  private void verifyDetails(DepartureTable table,
                             InputHandler inputHandler, TrainDeparture departure) {
    Renderer.renderDetails(departure); // Render the details of the new departure

    // Prompt the user to verify the details of the new departure
    String isCorrectAnswer = inputHandler.getInput(
        "Is this correct?",
        "[Y/n]",
        REGEX_YN_FORMAT,
        true);

    // Add the new departure to the departure table if the user confirms
    if (isCorrectAnswer.isEmpty() || isCorrectAnswer.equalsIgnoreCase("Y")) {
      table.addDeparture(departure);
      Halt.pressEnterToContinue("The departure has been added.");

      // Abort if the user does not confirm
    } else if (isCorrectAnswer.equalsIgnoreCase("N")) {
      Halt.pressEnterToContinue("The departure will not be added. Aborting.");
    }
  }
}
